const express = require('express');
const Joi = require('joi');
const rateLimit = require('express-rate-limit');
const { authenticateToken } = require('../middleware/authentication');
const router = express.Router();

// Rate limiting for customer endpoints
const customerLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 50, // 50 requests per window
  message: 'Too many requests, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
});

// Apply rate limiting and authentication to all routes
router.use(customerLimiter);
router.use(authenticateToken);

/**
 * GET /api/customers/my-bookings
 * Get customer's bookings and repair history
 */
router.get('/my-bookings', async (req, res) => {
  const client = await req.pool.connect();
  
  try {
    const userId = req.user.id;
    
    // Get all bookings for the authenticated customer
    const bookingsQuery = `
      SELECT 
        b.id,
        dm.name as device_model,
        db.name as device_brand,
        dc.name as device_category,
        b."repairType" as repair_type,
        b.status,
        b."problemDescription" as problem_description,
        b."basePrice" as base_price,
        b."finalPrice" as final_price,
        b."createdAt" as created_at,
        b."updatedAt" as updated_at,
        b."scheduledDate" as estimated_completion,
        u."firstName" as technician_first_name,
        u."lastName" as technician_last_name
      FROM bookings b
      LEFT JOIN device_models dm ON b."deviceModelId" = dm.id
      LEFT JOIN device_brands db ON dm."brandId" = db.id
      LEFT JOIN device_categories dc ON db."categoryId" = dc.id
      LEFT JOIN users u ON b."assignedTechnicianId" = u.id
      WHERE b."customerId" = $1
      ORDER BY b."createdAt" DESC
    `;
    
    const bookingsResult = await client.query(bookingsQuery, [userId]);
    
    // Transform the data to match frontend interface
    const bookings = bookingsResult.rows.map(row => ({
      id: row.id,
      deviceModel: row.device_model,
      deviceBrand: row.device_brand,
      deviceCategory: row.device_category,
      repairType: row.repair_type,
      status: row.status,
      problemDescription: row.problem_description,
      basePrice: parseFloat(row.base_price),
      finalPrice: parseFloat(row.final_price),
      createdAt: row.created_at.toISOString(),
      updatedAt: row.updated_at.toISOString(),
      estimatedCompletion: row.estimated_completion ? row.estimated_completion.toISOString() : null,
      assignedTechnician: row.technician_first_name ? {
        firstName: row.technician_first_name,
        lastName: row.technician_last_name
      } : null
    }));

    res.json({
      success: true,
      data: bookings
    });

  } catch (error) {
    console.error('Error fetching customer bookings:', error);
    res.status(500).json({
      error: 'Failed to fetch bookings',
      message: error.message
    });
  } finally {
    client.release();
  }
});

/**
 * GET /api/customers/dashboard-stats
 * Get customer dashboard statistics
 */
router.get('/dashboard-stats', async (req, res) => {
  const client = await req.pool.connect();
  
  try {
    const userId = req.user.id;
    
    // Get booking statistics
    const statsQuery = `
      SELECT 
        COUNT(*) as total_bookings,
        COUNT(CASE WHEN status IN ('PENDING', 'CONFIRMED', 'IN_PROGRESS') THEN 1 END) as active_bookings,
        COUNT(CASE WHEN status = 'COMPLETED' THEN 1 END) as completed_bookings,
        COALESCE(SUM("finalPrice"), 0) as total_spent,
        MAX("createdAt") as last_booking_date
      FROM bookings 
      WHERE "customerId" = $1
    `;
    
    const statsResult = await client.query(statsQuery, [userId]);
    const stats = statsResult.rows[0];
    
    // Get average rating (mock for now - would need reviews table)
    const averageRating = 4.8;
    
    res.json({
      success: true,
      data: {
        totalBookings: parseInt(stats.total_bookings),
        activeBookings: parseInt(stats.active_bookings),
        completedBookings: parseInt(stats.completed_bookings),
        totalSpent: parseFloat(stats.total_spent),
        averageRating: averageRating,
        lastBookingDate: stats.last_booking_date ? stats.last_booking_date.toISOString() : ''
      }
    });

  } catch (error) {
    console.error('Error fetching customer stats:', error);
    res.status(500).json({
      error: 'Failed to fetch statistics',
      message: error.message
    });
  } finally {
    client.release();
  }
});

/**
 * GET /api/customers/recent-activity
 * Get customer's recent activity feed
 */
router.get('/recent-activity', async (req, res) => {
  const client = await req.pool.connect();
  
  try {
    const userId = req.user.id;
    
    // Get recent status changes and updates (would need activity log table)
    // For now, simulate recent activities based on booking updates
    const activityQuery = `
      SELECT 
        b.id as booking_id,
        b.status,
        b."updatedAt" as updated_at,
        dm.name as device_model,
        db.name as device_brand,
        u."firstName" as technician_first_name,
        u."lastName" as technician_last_name
      FROM bookings b
      LEFT JOIN device_models dm ON b."deviceModelId" = dm.id
      LEFT JOIN device_brands db ON dm."brandId" = db.id
      LEFT JOIN users u ON b."assignedTechnicianId" = u.id
      WHERE b."customerId" = $1 
        AND b."updatedAt" >= NOW() - INTERVAL '7 days'
      ORDER BY b."updatedAt" DESC
      LIMIT 10
    `;
    
    const activityResult = await client.query(activityQuery, [userId]);
    
    // Transform to activity feed format
    const activities = activityResult.rows.map(row => {
      let message = '';
      let type = 'status_change';
      
      switch (row.status) {
        case 'CONFIRMED':
          message = `Your ${row.device_brand} ${row.device_model} repair has been confirmed`;
          break;
        case 'IN_PROGRESS':
          message = `Your ${row.device_brand} ${row.device_model} repair is now in progress`;
          break;
        case 'READY_FOR_PICKUP':
          message = `Your ${row.device_brand} ${row.device_model} is ready for pickup!`;
          break;
        case 'COMPLETED':
          message = `Your ${row.device_brand} ${row.device_model} repair has been completed`;
          break;
        default:
          message = `Update on your ${row.device_brand} ${row.device_model} repair`;
      }
      
      if (row.technician_first_name && row.status === 'IN_PROGRESS') {
        type = 'technician_assigned';
        message = `${row.technician_first_name} ${row.technician_last_name} has been assigned to your repair`;
      }
      
      return {
        type,
        bookingId: row.booking_id,
        message,
        timestamp: row.updated_at.toISOString()
      };
    });

    res.json({
      success: true,
      data: activities
    });

  } catch (error) {
    console.error('Error fetching recent activity:', error);
    res.status(500).json({
      error: 'Failed to fetch recent activity',
      message: error.message
    });
  } finally {
    client.release();
  }
});

/**
 * GET /api/customers/profile
 * Get customer profile information
 */
router.get('/profile', async (req, res) => {
  const client = await req.pool.connect();
  
  try {
    const userId = req.user.id;
    
    const profileQuery = `
      SELECT 
        id,
        email,
        "firstName" as first_name,
        "lastName" as last_name,
        phone,
        "createdAt" as created_at,
        "isVerified" as email_verified
      FROM users 
      WHERE id = $1 AND role = 'CUSTOMER'
    `;
    
    const profileResult = await client.query(profileQuery, [userId]);
    
    if (profileResult.rows.length === 0) {
      return res.status(404).json({
        error: 'Profile not found'
      });
    }
    
    const profile = profileResult.rows[0];
    
    res.json({
      success: true,
      data: {
        id: profile.id,
        email: profile.email,
        firstName: profile.first_name,
        lastName: profile.last_name,
        phone: profile.phone,
        address: profile.address,
        createdAt: profile.created_at.toISOString(),
        emailVerified: profile.email_verified,
        twoFactorEnabled: profile.two_factor_enabled
      }
    });

  } catch (error) {
    console.error('Error fetching customer profile:', error);
    res.status(500).json({
      error: 'Failed to fetch profile',
      message: error.message
    });
  } finally {
    client.release();
  }
});

/**
 * PUT /api/customers/profile
 * Update customer profile information
 */
router.put('/profile', async (req, res) => {
  const client = await req.pool.connect();
  
  try {
    const userId = req.user.id;
    
    // Validation schema
    const updateSchema = Joi.object({
      firstName: Joi.string().min(2).max(50).optional(),
      lastName: Joi.string().min(2).max(50).optional(),
      phone: Joi.string().pattern(/^\+?[\d\s\-\(\)]+$/).optional().allow(''),
      address: Joi.string().max(500).optional().allow('')
    });
    
    const { error, value } = updateSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        error: 'Validation failed',
        details: error.details.map(detail => detail.message)
      });
    }
    
    // Build dynamic update query
    const updates = [];
    const values = [];
    let paramCount = 1;
    
    Object.entries(value).forEach(([key, val]) => {
      if (val !== undefined) {
        const dbField = key === 'firstName' ? '"firstName"' : 
                       key === 'lastName' ? '"lastName"' : key;
        updates.push(`${dbField} = $${paramCount}`);
        values.push(val);
        paramCount++;
      }
    });
    
    if (updates.length === 0) {
      return res.status(400).json({
        error: 'No valid fields to update'
      });
    }
    
    // Add user ID and timestamp
    updates.push(`"updatedAt" = $${paramCount}`);
    values.push(new Date());
    paramCount++;
    values.push(userId);
    
    const updateQuery = `
      UPDATE users 
      SET ${updates.join(', ')}
      WHERE id = $${paramCount} AND role = 'CUSTOMER'
      RETURNING id, email, "firstName", "lastName", phone, "updatedAt"
    `;
    
    await client.query('BEGIN');
    const result = await client.query(updateQuery, values);
    
    if (result.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(404).json({
        error: 'Profile not found'
      });
    }
    
    await client.query('COMMIT');
    const updatedProfile = result.rows[0];
    
    res.json({
      success: true,
      data: {
        id: updatedProfile.id,
        email: updatedProfile.email,
        firstName: updatedProfile.firstName,
        lastName: updatedProfile.lastName,
        phone: updatedProfile.phone,
        updatedAt: updatedProfile.updatedAt.toISOString()
      }
    });

  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error updating customer profile:', error);
    res.status(500).json({
      error: 'Failed to update profile',
      message: error.message
    });
  } finally {
    client.release();
  }
});

/**
 * POST /api/customers/upload-device-photo
 * Upload device photos for repair documentation
 */
router.post('/upload-device-photo', async (req, res) => {
  // This would typically use multer for file upload
  // For now, return a placeholder response
  res.json({
    success: true,
    message: 'File upload endpoint ready for implementation',
    data: {
      uploadUrl: '/api/customers/upload-device-photo',
      supportedFormats: ['jpg', 'jpeg', 'png', 'webp'],
      maxSize: '10MB'
    }
  });
});

module.exports = router;