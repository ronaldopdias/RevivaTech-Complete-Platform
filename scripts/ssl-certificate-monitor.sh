#!/bin/bash

#
# SSL Certificate Monitor for RevivaTech
# Monitors certificate expiry and SSL security for all domains
#
# Usage: ./ssl-certificate-monitor.sh [--alert] [--email user@domain.com]
#

set -e

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
PURPLE='\033[0;35m'
NC='\033[0m'

# Configuration
DOMAINS=("revivatech.co.uk" "www.revivatech.co.uk" "revivatech.com.br" "www.revivatech.com.br" "crm.revivatech.co.uk" "crm.revivatech.com.br")
WARNING_DAYS=30
CRITICAL_DAYS=7
LOG_FILE="/var/log/ssl-certificate-monitor.log"
ALERT_EMAIL=""
SEND_ALERTS=false

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --alert)
            SEND_ALERTS=true
            shift
            ;;
        --email)
            ALERT_EMAIL="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: $0 [--alert] [--email user@domain.com]"
            echo "  --alert     Send email alerts for certificate issues"
            echo "  --email     Email address for alerts"
            exit 0
            ;;
        *)
            echo "Unknown option $1"
            exit 1
            ;;
    esac
done

# Logging function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') $1" | tee -a "$LOG_FILE"
}

# Check if a domain certificate is valid and get expiry info
check_certificate() {
    local domain="$1"
    local port="${2:-443}"
    
    echo -e "${BLUE}üîç Checking certificate for $domain:$port${NC}"
    
    # Get certificate information
    local cert_info
    cert_info=$(openssl s_client -connect "$domain:$port" -servername "$domain" 2>/dev/null | openssl x509 -noout -text 2>/dev/null)
    
    if [ $? -ne 0 ]; then
        echo -e "${RED}‚ùå Failed to retrieve certificate for $domain${NC}"
        log "ERROR: Could not retrieve certificate for $domain"
        return 1
    fi
    
    # Extract certificate details
    local not_after
    not_after=$(echo "$cert_info" | grep "Not After" | cut -d: -f2- | xargs)
    
    local issuer
    issuer=$(echo "$cert_info" | grep "Issuer:" | cut -d: -f2- | xargs)
    
    local subject
    subject=$(echo "$cert_info" | grep "Subject:" | cut -d: -f2- | xargs)
    
    local san
    san=$(echo "$cert_info" | grep -A1 "Subject Alternative Name" | tail -n1 | xargs)
    
    # Convert expiry date to seconds since epoch
    local expiry_epoch
    expiry_epoch=$(date -d "$not_after" +%s 2>/dev/null)
    
    if [ $? -ne 0 ]; then
        echo -e "${RED}‚ùå Could not parse certificate expiry date for $domain${NC}"
        log "ERROR: Could not parse expiry date for $domain: $not_after"
        return 1
    fi
    
    # Calculate days until expiry
    local current_epoch
    current_epoch=$(date +%s)
    local days_until_expiry
    days_until_expiry=$(( (expiry_epoch - current_epoch) / 86400 ))
    
    # Display certificate information
    echo -e "${GREEN}   ‚úÖ Certificate retrieved successfully${NC}"
    echo -e "${YELLOW}   üìã Subject: $subject${NC}"
    echo -e "${YELLOW}   üè¢ Issuer: $issuer${NC}"
    echo -e "${YELLOW}   üìÖ Expires: $not_after${NC}"
    echo -e "${YELLOW}   üóìÔ∏è  Days until expiry: $days_until_expiry${NC}"
    
    if [ -n "$san" ]; then
        echo -e "${YELLOW}   üîó Alternative Names: $san${NC}"
    fi
    
    # Check certificate status
    local status="OK"
    local alert_needed=false
    
    if [ $days_until_expiry -le $CRITICAL_DAYS ]; then
        echo -e "${RED}   üö® CRITICAL: Certificate expires in $days_until_expiry days!${NC}"
        status="CRITICAL"
        alert_needed=true
        log "CRITICAL: Certificate for $domain expires in $days_until_expiry days"
    elif [ $days_until_expiry -le $WARNING_DAYS ]; then
        echo -e "${YELLOW}   ‚ö†Ô∏è  WARNING: Certificate expires in $days_until_expiry days${NC}"
        status="WARNING"
        alert_needed=true
        log "WARNING: Certificate for $domain expires in $days_until_expiry days"
    else
        echo -e "${GREEN}   ‚úÖ Certificate is valid for $days_until_expiry days${NC}"
        log "INFO: Certificate for $domain is valid for $days_until_expiry days"
    fi
    
    # Send alert if needed
    if [ "$alert_needed" = true ] && [ "$SEND_ALERTS" = true ] && [ -n "$ALERT_EMAIL" ]; then
        send_alert "$domain" "$status" "$days_until_expiry" "$not_after"
    fi
    
    echo ""
    return 0
}

# Send email alert
send_alert() {
    local domain="$1"
    local status="$2"
    local days="$3"
    local expiry_date="$4"
    
    local subject="[$status] SSL Certificate Alert for $domain"
    local body="SSL Certificate Alert for RevivaTech

Domain: $domain
Status: $status
Days until expiry: $days
Expiry date: $expiry_date

Please renew the certificate before it expires to avoid service disruption.

This alert was generated by the RevivaTech SSL Certificate Monitor.
"
    
    echo "$body" | mail -s "$subject" "$ALERT_EMAIL" 2>/dev/null || {
        log "ERROR: Failed to send email alert to $ALERT_EMAIL"
        echo -e "${RED}‚ùå Failed to send email alert${NC}"
    }
    
    log "INFO: Alert sent to $ALERT_EMAIL for $domain ($status)"
}

# Check SSL security grade (basic check)
check_ssl_security() {
    local domain="$1"
    
    echo -e "${BLUE}üîí Checking SSL security for $domain${NC}"
    
    # Check SSL/TLS protocols
    local protocols=()
    
    # Test TLS 1.3
    if openssl s_client -connect "$domain:443" -tls1_3 -quiet 2>/dev/null < /dev/null | grep -q "Protocol.*TLSv1.3"; then
        protocols+=("TLS 1.3")
    fi
    
    # Test TLS 1.2
    if openssl s_client -connect "$domain:443" -tls1_2 -quiet 2>/dev/null < /dev/null | grep -q "Protocol.*TLSv1.2"; then
        protocols+=("TLS 1.2")
    fi
    
    # Test TLS 1.1 (should be disabled)
    if openssl s_client -connect "$domain:443" -tls1_1 -quiet 2>/dev/null < /dev/null | grep -q "Protocol.*TLSv1.1"; then
        protocols+=("TLS 1.1 ‚ö†Ô∏è")
    fi
    
    # Test TLS 1.0 (should be disabled)
    if openssl s_client -connect "$domain:443" -tls1 -quiet 2>/dev/null < /dev/null | grep -q "Protocol.*TLSv1"; then
        protocols+=("TLS 1.0 ‚ùå")
    fi
    
    echo -e "${YELLOW}   üîê Supported protocols: ${protocols[*]}${NC}"
    
    # Check for HSTS header
    local hsts
    hsts=$(curl -s -I "https://$domain" 2>/dev/null | grep -i "strict-transport-security" || echo "Not found")
    
    if [[ "$hsts" == *"max-age"* ]]; then
        echo -e "${GREEN}   ‚úÖ HSTS enabled: $hsts${NC}"
    else
        echo -e "${RED}   ‚ùå HSTS not enabled${NC}"
    fi
    
    echo ""
}

# Check Let's Encrypt renewal status
check_letsencrypt_renewal() {
    echo -e "${BLUE}üîÑ Checking Let's Encrypt renewal status${NC}"
    
    if [ -f "/etc/letsencrypt/renewal/revivatech.co.uk.conf" ]; then
        echo -e "${GREEN}   ‚úÖ Let's Encrypt renewal configuration exists${NC}"
        
        # Check if certbot is installed and working
        if command -v certbot &> /dev/null; then
            echo -e "${GREEN}   ‚úÖ Certbot is installed${NC}"
            
            # Test renewal (dry run)
            echo -e "${YELLOW}   üß™ Testing certificate renewal (dry run)...${NC}"
            if timeout 60 certbot renew --dry-run --cert-name revivatech.co.uk &>/dev/null; then
                echo -e "${GREEN}   ‚úÖ Certificate renewal test successful${NC}"
                log "INFO: Let's Encrypt renewal test successful"
            else
                echo -e "${RED}   ‚ùå Certificate renewal test failed${NC}"
                log "ERROR: Let's Encrypt renewal test failed"
            fi
        else
            echo -e "${RED}   ‚ùå Certbot not installed${NC}"
            log "ERROR: Certbot not installed"
        fi
        
        # Check renewal timer
        if systemctl is-enabled certbot.timer &>/dev/null; then
            echo -e "${GREEN}   ‚úÖ Certbot renewal timer is enabled${NC}"
            
            local next_run
            next_run=$(systemctl list-timers certbot.timer --no-legend | awk '{print $1, $2}')
            echo -e "${YELLOW}   ‚è∞ Next renewal: $next_run${NC}"
        else
            echo -e "${RED}   ‚ùå Certbot renewal timer not enabled${NC}"
            log "WARNING: Certbot renewal timer not enabled"
        fi
    else
        echo -e "${RED}   ‚ùå Let's Encrypt renewal configuration not found${NC}"
        log "ERROR: Let's Encrypt renewal configuration not found"
    fi
    
    echo ""
}

# Main monitoring function
main() {
    echo -e "${PURPLE}üîç RevivaTech SSL Certificate Monitor${NC}"
    echo -e "${PURPLE}=====================================${NC}"
    echo -e "${BLUE}üìÖ Date: $(date)${NC}"
    echo -e "${BLUE}‚öôÔ∏è  Configuration: WARNING=$WARNING_DAYS days, CRITICAL=$CRITICAL_DAYS days${NC}"
    
    if [ "$SEND_ALERTS" = true ]; then
        echo -e "${BLUE}üìß Email alerts enabled${NC}"
        if [ -n "$ALERT_EMAIL" ]; then
            echo -e "${BLUE}üì¨ Alert email: $ALERT_EMAIL${NC}"
        fi
    fi
    
    echo ""
    
    log "INFO: SSL Certificate Monitor started"
    
    # Check certificates for all domains
    local failed_checks=0
    for domain in "${DOMAINS[@]}"; do
        if ! check_certificate "$domain"; then
            ((failed_checks++))
        fi
        
        # Check SSL security for production domains
        if [[ "$domain" == "revivatech.co.uk" || "$domain" == "revivatech.com.br" ]]; then
            check_ssl_security "$domain"
        fi
    done
    
    # Check Let's Encrypt renewal
    check_letsencrypt_renewal
    
    # Summary
    echo -e "${PURPLE}üìä MONITORING SUMMARY${NC}"
    echo -e "${PURPLE}=====================${NC}"
    
    if [ $failed_checks -eq 0 ]; then
        echo -e "${GREEN}‚úÖ All certificate checks passed${NC}"
        log "INFO: All certificate checks passed"
    else
        echo -e "${RED}‚ùå $failed_checks certificate check(s) failed${NC}"
        log "WARNING: $failed_checks certificate check(s) failed"
    fi
    
    echo -e "${BLUE}üìù Full log available at: $LOG_FILE${NC}"
    echo -e "${BLUE}üîÑ Run with --alert --email your@email.com to enable alerts${NC}"
    
    log "INFO: SSL Certificate Monitor completed"
}

# Create log file if it doesn't exist
mkdir -p "$(dirname "$LOG_FILE")"
touch "$LOG_FILE"

# Run main function
main "$@"