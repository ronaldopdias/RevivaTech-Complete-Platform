const express = require('express');
const helmet = require('helmet');
const cors = require('cors');
const compression = require('compression');
const session = require('express-session');
const cookieParser = require('cookie-parser');
const rateLimit = require('express-rate-limit');
const { Pool } = require('pg');
const Redis = require('redis');
const winston = require('winston');
const { createServer } = require('http');
const { Server } = require('socket.io');
const jwt = require('jsonwebtoken');
require('dotenv').config();

// Marketing Automation Services
const MarketingAutomation = require('./services/MarketingAutomation');
const AudienceBuilder = require('./services/AudienceBuilder');
const PersonalizationEngine = require('./services/PersonalizationEngine');

// Communication Services
const NotificationService = require('./services/NotificationService');
const ChatService = require('./services/ChatService');
const EmailService = require('./services/EmailService');
const EmailTemplateEngine = require('./services/EmailTemplateEngine');

// AI Diagnostic Services
const AIRealtimeStreaming = require('./services/AIRealtimeStreaming');

// Initialize Express app and HTTP server
const app = express();
const server = createServer(app);
const PORT = process.env.PORT || 3011;

// Initialize Socket.IO
const io = new Server(server, {
  cors: {
    origin: [
      'http://localhost:3010',
      'http://localhost:3000',
      'https://revivatech.co.uk',
      'https://www.revivatech.co.uk',
      'https://revivatech.com.br',
      'https://www.revivatech.com.br'
    ],
    credentials: true,
    methods: ['GET', 'POST']
  }
});

// Logger configuration
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
});

// PostgreSQL connection
const pool = new Pool({
  user: process.env.DB_USER || 'revivatech_user',
  host: process.env.DB_HOST || 'localhost',
  database: process.env.DB_NAME || 'revivatech_new',
  password: process.env.DB_PASSWORD || 'revivatech_password',
  port: process.env.DB_PORT || 5435,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

// Redis connection
const redisClient = Redis.createClient({
  url: `redis://${process.env.REDIS_PASSWORD ? ':' + process.env.REDIS_PASSWORD + '@' : ''}${process.env.REDIS_HOST || 'localhost'}:${process.env.REDIS_PORT || 6383}`,
});

// Connect to Redis
redisClient.connect().catch(console.error);

// Trust proxy for nginx
app.set('trust proxy', 1);

// Security middleware
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https:"],
      scriptSrc: ["'self'", "'unsafe-inline'", "https:"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "https:", "wss:"],
      fontSrc: ["'self'", "https:", "data:"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'self'"],
    },
  },
  crossOriginEmbedderPolicy: false
}));

// CORS configuration
const corsOptions = {
  origin: function (origin, callback) {
    const allowedOrigins = [
      'http://localhost:3010',
      'http://localhost:3000',
      'https://revivatech.co.uk',
      'https://www.revivatech.co.uk',
      'https://revivatech.com.br',
      'https://www.revivatech.com.br'
    ];
    
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept', 'Origin']
};

app.use(cors(corsOptions));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.',
  standardHeaders: true,
  legacyHeaders: false,
});

app.use(limiter);

// Body parsing middleware
app.use(compression());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(cookieParser());

// Session configuration
app.use(session({
  secret: process.env.SESSION_SECRET || 'your-secret-key-change-in-production',
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 1000 * 60 * 60 * 24 // 24 hours
  }
}));

// Request logging
app.use((req, res, next) => {
  logger.info(`${req.method} ${req.path} - IP: ${req.ip}`);
  next();
});

// Database connection test
pool.on('connect', () => {
  logger.info('Connected to PostgreSQL database');
});

pool.on('error', (err) => {
  logger.error('PostgreSQL pool error:', err);
});

// Redis connection test
redisClient.on('connect', () => {
  logger.info('Connected to Redis');
});

redisClient.on('error', (err) => {
  logger.error('Redis error:', err);
});

// Initialize Analytics WebSocket clients storage
app.locals.wsClients = new Set();

// Initialize Marketing Automation Services
let marketingAutomation, audienceBuilder, personalizationEngine;

(async () => {
  try {
    logger.info('ðŸš€ Initializing Marketing Automation Services...');
    
    // Initialize services
    marketingAutomation = new MarketingAutomation();
    audienceBuilder = new AudienceBuilder();
    personalizationEngine = new PersonalizationEngine();
    
    // Initialize all services
    await Promise.all([
      marketingAutomation.initialize(),
      audienceBuilder.initialize(),
      personalizationEngine.initialize()
    ]);
    
    // Make services available to routes
    app.locals.marketingAutomation = marketingAutomation;
    app.locals.audienceBuilder = audienceBuilder;
    app.locals.personalizationEngine = personalizationEngine;
    
    logger.info('âœ… Marketing Automation Services initialized successfully');
    
    // Setup event listeners for real-time automation
    setupMarketingAutomationListeners();
    
  } catch (error) {
    logger.error('âŒ Marketing Automation Services initialization failed:', error);
  }
})();

// Initialize Communication Services
let notificationService;
let chatService;
let emailService;
let emailTemplateEngine;

(async () => {
  try {
    logger.info('ðŸš€ Initializing Communication Services...');
    
    // Initialize email template engine
    emailTemplateEngine = new EmailTemplateEngine({
      enablePersonalization: true,
      enableTracking: true,
      cacheTemplates: true,
      complianceMode: process.env.NODE_ENV === 'production' ? 'strict' : 'moderate'
    });
    await emailTemplateEngine.initialize();
    
    // Initialize email service
    emailService = new EmailService({
      provider: 'sendgrid', // Can be changed to 'nodemailer' if needed
      enableSandbox: process.env.NODE_ENV !== 'production',
      enableTracking: true
    });
    await emailService.initialize();
    
    // Initialize notification service with Socket.IO
    notificationService = new NotificationService(io);
    
    // Initialize chat service with Socket.IO
    chatService = new ChatService(io);
    
    // Connect email service to notification service
    setupEmailNotificationListeners();
    
    // Make services available to routes
    app.locals.notificationService = notificationService;
    app.locals.chatService = chatService;
    app.locals.emailService = emailService;
    app.locals.emailTemplateEngine = emailTemplateEngine;
    
    logger.info('âœ… Communication Services initialized successfully');
    
    // Setup event listeners for communication services
    setupCommunicationListeners();
    
  } catch (error) {
    logger.error('âŒ Communication Services initialization failed:', error);
  }
})();

function setupMarketingAutomationListeners() {
  // Listen for marketing automation events
  marketingAutomation.on('automationCompleted', (data) => {
    logger.info(`ðŸŽ¯ Marketing automation completed: ${data.automationId}`);
    
    // Emit to admin WebSocket for real-time monitoring
    if (io) {
      io.to('admin').emit('marketing:automation:completed', data);
    }
  });
  
  audienceBuilder.on('audienceCreated', (data) => {
    logger.info(`ðŸ‘¥ New audience created: ${data.name} (${data.size} users)`);
    
    if (io) {
      io.to('admin').emit('marketing:audience:created', data);
    }
  });
  
  audienceBuilder.on('audienceSynced', (data) => {
    logger.info(`ðŸ”„ Audience synced: ${data.audienceId} to ${data.platform}`);
    
    if (io) {
      io.to('admin').emit('marketing:audience:synced', data);
    }
  });
  
  personalizationEngine.on('personalizationServed', (data) => {
    // Log high-level personalization metrics
    if (Math.random() < 0.1) { // Log 10% of personalizations to avoid spam
      logger.info(`ðŸŽ¯ Personalization served: ${data.personalization.level} level in ${data.responseTime}ms`);
    }
  });
}

// Email helper functions
async function sendBookingConfirmationEmail(userId, bookingData) {
  try {
    // Get user information from database
    const userQuery = 'SELECT email, "firstName", "lastName" FROM users WHERE id = $1';
    const userResult = await pool.query(userQuery, [userId]);
    
    if (userResult.rows.length === 0) {
      throw new Error(`User not found: ${userId}`);
    }
    
    const user = userResult.rows[0];
    
    // Load booking confirmation template
    const fs = require('fs').promises;
    const path = require('path');
    const templatePath = path.join(__dirname, 'templates', 'booking-confirmation.html');
    const textTemplatePath = path.join(__dirname, 'templates', 'booking-confirmation.txt');
    
    const htmlTemplate = await fs.readFile(templatePath, 'utf8');
    const textTemplate = await fs.readFile(textTemplatePath, 'utf8');
    
    // Prepare template data
    const templateData = {
      user: {
        first_name: user.firstName || 'Valued Customer',
        name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || 'Valued Customer',
        email: user.email
      },
      booking: {
        id: bookingData.id,
        service_type: bookingData.repairType.replace('_', ' '),
        appointment_date: bookingData.preferredDate ? new Date(bookingData.preferredDate).toLocaleDateString('en-GB') : 'To be scheduled',
        urgency_level: bookingData.urgencyLevel
      },
      repair: {
        brand: bookingData.deviceBrand || 'Unknown',
        model: bookingData.deviceModel || 'Unknown',
        issue: bookingData.problemDescription,
        status: bookingData.status || 'PENDING',
        cost_estimate: bookingData.basePrice || bookingData.finalPrice || '0.00'
      },
      company: {
        name: 'RevivaTech',
        phone: '+44 20 1234 5678',
        email: 'support@revivatech.co.uk',
        address: '123 Tech Street, London, UK',
        support_hours: 'Monday - Friday, 9 AM - 6 PM GMT'
      },
      system: {
        date: new Date().toLocaleDateString(),
        year: new Date().getFullYear(),
        unsubscribe_url: `https://revivatech.co.uk/unsubscribe?token=${userId}`,
        preferences_url: `https://revivatech.co.uk/email-preferences?token=${userId}`,
        tracking_pixel: ''
      }
    };
    
    // Process templates with variables
    const processedHtml = await processEmailTemplate(htmlTemplate, templateData);
    const processedText = await processEmailTemplate(textTemplate, templateData);
    
    // Send email
    const emailData = {
      id: `booking_conf_${bookingData.id}`,
      to: user.email,
      subject: `âœ… Booking Confirmed - Your ${templateData.booking.service_type} Repair`,
      html: processedHtml,
      text: processedText,
      metadata: {
        userId,
        bookingId: bookingData.id,
        type: 'booking_confirmation'
      },
      categories: ['booking', 'confirmation', 'transactional']
    };
    
    const result = await emailService.sendEmail(emailData);
    logger.info(`âœ… Booking confirmation email sent: ${result.messageId} to ${user.email}`);
    
    return result;
  } catch (error) {
    logger.error(`âŒ Failed to send booking confirmation email:`, error);
    throw error;
  }
}

async function processEmailTemplate(template, data) {
  // Simple template variable replacement
  let processed = template;
  
  // Process {{variable.path}} syntax
  const variableRegex = /\{\{([^}#\/\s]+)\}\}/g;
  processed = processed.replace(variableRegex, (match, variable) => {
    const path = variable.trim();
    return getNestedValue(data, path) || '';
  });
  
  // Process {{#if condition}}...{{/if}} blocks
  const conditionalRegex = /\{\{#if\s+([^}]+)\}\}([\s\S]*?)\{\{\/if\}\}/g;
  processed = processed.replace(conditionalRegex, (match, condition, content) => {
    const value = getNestedValue(data, condition.trim());
    return value ? content : '';
  });
  
  // Add greeting based on time of day
  const hour = new Date().getHours();
  let greeting = 'Hello';
  if (hour < 12) greeting = 'Good morning';
  else if (hour < 17) greeting = 'Good afternoon';
  else greeting = 'Good evening';
  
  processed = processed.replace(/\{\{greeting\}\}/g, greeting);
  
  return processed;
}

function getNestedValue(obj, path) {
  return path.split('.').reduce((current, key) => current && current[key], obj);
}

function setupEmailNotificationListeners() {
  // Listen for email notification requests from notification service
  notificationService.on('emailNotificationRequested', async (data) => {
    try {
      logger.info(`ðŸ“§ Email notification requested for user ${data.userId}: ${data.subject}`);
      
      // Send email using EmailService
      const emailData = {
        id: `email_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        to: data.userEmail || data.email,
        subject: data.subject,
        html: data.message,
        metadata: {
          userId: data.userId,
          notificationId: data.notificationId,
          type: 'notification'
        }
      };
      
      const result = await emailService.sendEmail(emailData);
      logger.info(`âœ… Email sent successfully: ${result.messageId}`);
      
    } catch (error) {
      logger.error(`âŒ Failed to send email notification:`, error);
    }
  });
  
  // Listen for booking confirmation email requests
  notificationService.on('bookingConfirmationRequested', async (data) => {
    try {
      logger.info(`ðŸ“§ Booking confirmation email requested for user ${data.userId}`);
      await sendBookingConfirmationEmail(data.userId, data.bookingData);
    } catch (error) {
      logger.error(`âŒ Failed to send booking confirmation email:`, error);
    }
  });
}

function setupCommunicationListeners() {
  // Listen for notification service events
  notificationService.on('notificationSent', (data) => {
    logger.info(`ðŸ“± Notification sent: ${data.notificationId} to user ${data.userId}`);
  });
  
  // Legacy email notification handler (replaced by setupEmailNotificationListeners)
  // (keeping for backwards compatibility)
  
  // Listen for SMS notification requests from notification service
  notificationService.on('smsNotificationRequested', async (data) => {
    try {
      // Here you would integrate with the SMSService
      logger.info(`ðŸ“± SMS notification requested for user ${data.userId}`);
      // await smsService.sendTemplateMessage('notification', data);
    } catch (error) {
      logger.error('âŒ Failed to send SMS notification:', error);
    }
  });
}

// Routes
app.get('/health', async (req, res) => {
  try {
    // Test database connection
    const dbResult = await pool.query('SELECT NOW()');
    
    // Test Redis connection (simplified)
    let redisStatus = 'unknown';
    try {
      await redisClient.ping();
      redisStatus = 'connected';
    } catch (redisError) {
      redisStatus = 'disconnected';
    }
    
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      database: 'connected',
      redis: redisStatus,
      version: '2.0.0',
      analytics: 'enabled'
    });
  } catch (error) {
    logger.error('Health check failed:', error);
    res.status(500).json({
      status: 'unhealthy',
      error: error.message
    });
  }
});

// API routes
app.get('/api/info', (req, res) => {
  res.json({
    name: 'RevivaTech New Platform API',
    version: '2.0.0',
    environment: process.env.NODE_ENV || 'development',
    timestamp: new Date().toISOString(),
    features: ['analytics', 'websockets', 'real-time-tracking']
  });
});


// Data Recovery routes
app.get('/api/data-recovery/services', async (req, res) => {
  try {
    const services = [
      {
        id: 'standard',
        name: 'Standard Data Recovery',
        description: 'Professional data recovery for common drive failures',
        estimatedTime: '3-5 business days',
        basePrice: 299
      },
      {
        id: 'emergency',
        name: 'Emergency Data Recovery',
        description: '24/7 emergency service for critical data loss',
        estimatedTime: '24-48 hours',
        basePrice: 599
      },
      {
        id: 'forensic',
        name: 'Forensic Data Recovery',
        description: 'Specialized recovery with forensic documentation',
        estimatedTime: '5-7 business days',
        basePrice: 899
      }
    ];
    
    res.json({ services });
  } catch (error) {
    logger.error('Error fetching data recovery services:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Booking routes
app.post('/api/bookings', async (req, res) => {
  const client = await pool.connect();
  
  try {
    const {
      customerInfo,
      deviceAssessment,
      serviceSelection,
      prioritization
    } = req.body;

    // Validate required fields
    if (!customerInfo || !deviceAssessment || !serviceSelection) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    // Start transaction
    await client.query('BEGIN');

    // Insert customer if not exists
    const customerQuery = `
      INSERT INTO customers (email, first_name, last_name, phone, created_at)
      VALUES ($1, $2, $3, $4, NOW())
      ON CONFLICT (email) DO UPDATE SET
        first_name = EXCLUDED.first_name,
        last_name = EXCLUDED.last_name,
        phone = EXCLUDED.phone
      RETURNING id
    `;
    
    const customerResult = await client.query(customerQuery, [
      customerInfo.email,
      customerInfo.firstName,
      customerInfo.lastName,
      customerInfo.phone
    ]);
    
    const customerId = customerResult.rows[0].id;

    // Insert booking
    const bookingQuery = `
      INSERT INTO data_recovery_bookings (
        customer_id,
        device_assessment,
        service_selection,
        data_prioritization,
        status,
        created_at
      ) VALUES ($1, $2, $3, $4, $5, NOW())
      RETURNING id
    `;
    
    const bookingResult = await client.query(bookingQuery, [
      customerId,
      JSON.stringify(deviceAssessment),
      JSON.stringify(serviceSelection),
      JSON.stringify(prioritization || {}),
      'pending'
    ]);
    
    const bookingId = bookingResult.rows[0].id;

    // Commit transaction
    await client.query('COMMIT');

    logger.info(`New booking created: ${bookingId} for customer: ${customerId}`);

    res.status(201).json({
      success: true,
      bookingId,
      message: 'Booking created successfully'
    });

  } catch (error) {
    await client.query('ROLLBACK');
    logger.error('Error creating booking:', error);
    res.status(500).json({ error: 'Failed to create booking' });
  } finally {
    client.release();
  }
});

// Error handling middleware
app.use((err, req, res, next) => {
  logger.error('Unhandled error:', err);
  res.status(500).json({
    error: 'Internal server error',
    message: process.env.NODE_ENV === 'development' ? err.message : 'Something went wrong'
  });
});

// Import existing API routes
const authRoutes = require('./routes/auth');
const deviceRoutes = require('./routes/devices-simple');
const pricingRoutes = require('./routes/pricing-simple');
const emailRoutes = require('./routes/email');
const adminEmailRoutes = require('./routes/admin-email');
const emailConfigRoutes = require('./routes/email-config');
// const smsRoutes = require('./routes/sms'); // Commented out - file missing
const notificationRoutes = require('./routes/notifications');
const chatRoutes = require('./routes/chat');

// Import new Analytics routes
const { router: analyticsRoutes, setupWebSocketServer } = require('./routes/analytics');

// Import AI Diagnostic routes
const aiDiagnosticsRoutes = require('./routes/ai-diagnostics');
// Import AI Chatbot routes
const aiChatbotRoutes = require('./routes/ai-chatbot-simple');

// Import ML and Automation routes
const predictiveAnalyticsRoutes = require('./routes/predictive-analytics');
const inventoryManagementRoutes = require('./routes/inventory-management');
const workflowAutomationRoutes = require('./routes/workflow-automation');

// Middleware to add pool and logger to request
app.use('/api/auth', (req, res, next) => {
  req.pool = pool;
  req.logger = logger;
  next();
}, authRoutes);

app.use('/api/devices', (req, res, next) => {
  req.pool = pool;
  req.logger = logger;
  next();
}, deviceRoutes);

app.use('/api/pricing', (req, res, next) => {
  req.pool = pool;
  req.logger = logger;
  next();
}, pricingRoutes);

app.use('/api/email', (req, res, next) => {
  req.pool = pool;
  req.logger = logger;
  next();
}, emailRoutes);

app.use('/api/admin/email', (req, res, next) => {
  req.pool = pool;
  req.logger = logger;
  next();
}, adminEmailRoutes);

app.use('/api/admin/email-config', (req, res, next) => {
  req.pool = pool;
  req.logger = logger;
  next();
}, emailConfigRoutes);

// SMS routes commented out - file missing
// app.use('/api/sms', (req, res, next) => {
//   req.pool = pool;
//   req.logger = logger;
//   next();
// }, smsRoutes);

app.use('/api/notifications', (req, res, next) => {
  req.pool = pool;
  req.logger = logger;
  next();
}, notificationRoutes);

app.use('/api/chat', (req, res, next) => {
  req.pool = pool;
  req.logger = logger;
  next();
}, chatRoutes);

// Analytics routes with middleware
app.use('/api/analytics', (req, res, next) => {
  req.pool = pool;
  req.logger = logger;
  req.app = app; // For WebSocket client access
  next();
}, analyticsRoutes);

// AI Diagnostics routes with middleware
app.use('/api/ai-diagnostics', (req, res, next) => {
  req.pool = pool;
  req.logger = logger;
  req.app = app; // For WebSocket client access
  next();
}, aiDiagnosticsRoutes);

// AI Chatbot routes with middleware
app.use('/api/ai-chatbot', (req, res, next) => {
  req.pool = pool;
  req.logger = logger;
  req.app = app; // For WebSocket client access
  next();
}, aiChatbotRoutes);

// ML Predictive Analytics routes
app.use('/api/predictive-analytics', (req, res, next) => {
  req.pool = pool;
  req.logger = logger;
  next();
}, predictiveAnalyticsRoutes);

// Inventory Management routes
app.use('/api/inventory-management', (req, res, next) => {
  req.pool = pool;
  req.logger = logger;
  next();
}, inventoryManagementRoutes);

// Workflow Automation routes
app.use('/api/workflow-automation', (req, res, next) => {
  req.pool = pool;
  req.logger = logger;
  next();
}, workflowAutomationRoutes);

// Setup Analytics WebSocket Server
const { wss: analyticsWss, clients: analyticsClients } = setupWebSocketServer(server);
app.locals.analyticsWss = analyticsWss;
app.locals.wsClients = analyticsClients;

logger.info('Analytics WebSocket server initialized');

// Initialize AI Real-time Streaming Service
let aiStreamingService;
(async () => {
  try {
    logger.info('ðŸ¤– Initializing AI Real-time Streaming Service...');
    
    aiStreamingService = new AIRealtimeStreaming(server);
    await aiStreamingService.initialize();
    
    // Make AI streaming service available to routes
    app.locals.aiStreamingService = aiStreamingService;
    
    // Start periodic cleanup
    aiStreamingService.startPeriodicCleanup();
    
    logger.info('âœ… AI Real-time Streaming Service initialized successfully');
    
  } catch (error) {
    logger.error('âŒ AI Real-time Streaming Service initialization failed:', error);
  }
})();

// Marketing Automation API Routes
app.use('/api/marketing', (req, res, next) => {
  req.marketingAutomation = app.locals.marketingAutomation;
  req.audienceBuilder = app.locals.audienceBuilder;
  req.personalizationEngine = app.locals.personalizationEngine;
  req.logger = logger;
  next();
});

// Event processing endpoint
app.post('/api/marketing/events', async (req, res) => {
  try {
    const { marketingAutomation } = req;
    if (!marketingAutomation) {
      return res.status(503).json({ error: 'Marketing automation service not available' });
    }

    const result = await marketingAutomation.processEvent(req.body);
    res.json(result);
  } catch (error) {
    logger.error('Marketing event processing failed:', error);
    res.status(500).json({ error: 'Event processing failed' });
  }
});

// Personalization endpoint
app.post('/api/marketing/personalize', async (req, res) => {
  try {
    const { personalizationEngine } = req;
    if (!personalizationEngine) {
      return res.status(503).json({ error: 'Personalization service not available' });
    }

    const { userId, context } = req.body;
    const personalization = await personalizationEngine.getPersonalization(userId, context);
    res.json(personalization);
  } catch (error) {
    logger.error('Personalization failed:', error);
    res.status(500).json({ error: 'Personalization failed' });
  }
});

// Audience management endpoints
app.post('/api/marketing/audiences', async (req, res) => {
  try {
    const { audienceBuilder } = req;
    if (!audienceBuilder) {
      return res.status(503).json({ error: 'Audience builder service not available' });
    }

    const audience = await audienceBuilder.createCustomAudience(req.body);
    res.json(audience);
  } catch (error) {
    logger.error('Audience creation failed:', error);
    res.status(500).json({ error: 'Audience creation failed' });
  }
});

app.get('/api/marketing/audiences', async (req, res) => {
  try {
    const { audienceBuilder } = req;
    if (!audienceBuilder) {
      return res.status(503).json({ error: 'Audience builder service not available' });
    }

    const audiences = await audienceBuilder.getAllAudiences();
    res.json(audiences);
  } catch (error) {
    logger.error('Audience retrieval failed:', error);
    res.status(500).json({ error: 'Audience retrieval failed' });
  }
});

app.post('/api/marketing/audiences/:id/sync', async (req, res) => {
  try {
    const { audienceBuilder } = req;
    if (!audienceBuilder) {
      return res.status(503).json({ error: 'Audience builder service not available' });
    }

    const { platform = 'internal' } = req.body;
    const result = await audienceBuilder.syncAudience(req.params.id, platform);
    res.json(result);
  } catch (error) {
    logger.error('Audience sync failed:', error);
    res.status(500).json({ error: 'Audience sync failed' });
  }
});

// User profile management
app.post('/api/marketing/users/:userId/profile', async (req, res) => {
  try {
    const { audienceBuilder } = req;
    if (!audienceBuilder) {
      return res.status(503).json({ error: 'Audience builder service not available' });
    }

    const profile = await audienceBuilder.addUserProfile(req.params.userId, req.body);
    res.json(profile);
  } catch (error) {
    logger.error('User profile update failed:', error);
    res.status(500).json({ error: 'User profile update failed' });
  }
});

// Content variant endpoint
app.get('/api/marketing/content/:variantId', async (req, res) => {
  try {
    const { personalizationEngine } = req;
    if (!personalizationEngine) {
      return res.status(503).json({ error: 'Personalization service not available' });
    }

    const { variantType = 'default' } = req.query;
    const variant = await personalizationEngine.getContentVariant(req.params.variantId, variantType);
    
    if (!variant) {
      return res.status(404).json({ error: 'Content variant not found' });
    }
    
    res.json(variant);
  } catch (error) {
    logger.error('Content variant retrieval failed:', error);
    res.status(500).json({ error: 'Content variant retrieval failed' });
  }
});

// Marketing automation metrics
app.get('/api/marketing/metrics', async (req, res) => {
  try {
    const { marketingAutomation, audienceBuilder, personalizationEngine } = req;
    
    const metrics = {
      marketingAutomation: marketingAutomation?.getMetrics() || {},
      audienceBuilder: audienceBuilder?.getAudienceMetrics() || {},
      personalizationEngine: personalizationEngine?.getMetrics() || {},
      timestamp: Date.now()
    };
    
    res.json(metrics);
  } catch (error) {
    logger.error('Metrics retrieval failed:', error);
    res.status(500).json({ error: 'Metrics retrieval failed' });
  }
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({ error: 'Route not found' });
});

// WebSocket Authentication Middleware
io.use(async (socket, next) => {
  try {
    const token = socket.handshake.auth.token || socket.handshake.headers.authorization?.replace('Bearer ', '');
    
    // Development mode: Allow demo connections
    if (process.env.NODE_ENV === 'development' && (!token || token.startsWith('demo-') || token.includes('demo'))) {
      logger.info('ðŸš§ Development mode: Using demo user for WebSocket connection');
      socket.user = {
        id: 'demo-user-id',
        email: 'demo@customer.com',
        role: 'CUSTOMER',
        first_name: 'Demo',
        last_name: 'Customer'
      };
      socket.userId = 'demo-user-id';
      socket.userRole = 'CUSTOMER';
      return next();
    }
    
    if (!token) {
      return next(new Error('Authentication token required'));
    }

    // Verify JWT token
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret');
    
    // Get user details from database
    const userQuery = 'SELECT id, email, role, first_name, last_name FROM users WHERE id = $1';
    const userResult = await pool.query(userQuery, [decoded.userId]);
    
    if (userResult.rows.length === 0) {
      return next(new Error('User not found'));
    }

    socket.user = userResult.rows[0];
    socket.userId = decoded.userId;
    socket.userRole = decoded.role;
    
    logger.info(`WebSocket user authenticated: ${socket.user.email} (${socket.user.role})`);
    next();
  } catch (error) {
    logger.error('WebSocket authentication failed:', error.message);
    next(new Error('Authentication failed'));
  }
});

// WebSocket Connection Handling
io.on('connection', (socket) => {
  logger.info(`WebSocket connected: ${socket.user.email} (${socket.id})`);
  
  // Join user-specific room
  socket.join(`user:${socket.userId}`);
  
  // Join role-based rooms
  socket.join(`role:${socket.userRole}`);
  
  // Admin users get access to admin room
  if (['ADMIN', 'SUPER_ADMIN'].includes(socket.userRole)) {
    socket.join('admin');
    // Allow admins to join analytics room
    socket.join('analytics');
  }

  // Handle booking updates subscription
  socket.on('subscribe:bookings', (data) => {
    if (socket.userRole === 'CUSTOMER') {
      // Customers only get their own bookings
      socket.join(`customer:${socket.userId}:bookings`);
    } else if (['ADMIN', 'SUPER_ADMIN', 'TECHNICIAN'].includes(socket.userRole)) {
      // Staff get all bookings
      socket.join('bookings:all');
    }
    logger.info(`User ${socket.user.email} subscribed to booking updates`);
  });

  // Handle pricing updates subscription
  socket.on('subscribe:pricing', (data) => {
    socket.join('pricing:updates');
    logger.info(`User ${socket.user.email} subscribed to pricing updates`);
  });

  // Handle analytics subscription (admin only)
  socket.on('subscribe:analytics', (data) => {
    if (['ADMIN', 'SUPER_ADMIN'].includes(socket.userRole)) {
      socket.join('analytics:realtime');
      logger.info(`Admin ${socket.user.email} subscribed to analytics updates`);
      
      // Send initial analytics data
      socket.emit('analytics:connected', {
        message: 'Analytics subscription active',
        timestamp: new Date().toISOString()
      });
    }
  });

  // Handle live chat room joining
  socket.on('join:chat', (roomId) => {
    // Validate user has access to this chat room
    if (socket.userRole === 'CUSTOMER') {
      // Customers can only join their own chat rooms
      if (roomId.startsWith(`customer:${socket.userId}`)) {
        socket.join(roomId);
        logger.info(`Customer ${socket.user.email} joined chat room: ${roomId}`);
      }
    } else if (['ADMIN', 'SUPER_ADMIN', 'TECHNICIAN'].includes(socket.userRole)) {
      // Staff can join any chat room
      socket.join(roomId);
      logger.info(`Staff ${socket.user.email} joined chat room: ${roomId}`);
    }
  });

  // Handle disconnection
  socket.on('disconnect', (reason) => {
    logger.info(`WebSocket disconnected: ${socket.user.email} (${socket.id}) - Reason: ${reason}`);
  });

  // Handle errors
  socket.on('error', (error) => {
    logger.error(`WebSocket error for ${socket.user.email}:`, error);
  });

  // Send welcome message
  socket.emit('connected', {
    message: 'WebSocket connection established',
    user: {
      id: socket.user.id,
      email: socket.user.email,
      role: socket.user.role,
      name: `${socket.user.first_name} ${socket.user.last_name}`
    },
    features: ['bookings', 'pricing', 'analytics']
  });
});

// WebSocket Event Emitters (to be used by API routes)
const emitToUser = (userId, event, data) => {
  io.to(`user:${userId}`).emit(event, data);
};

const emitToRole = (role, event, data) => {
  io.to(`role:${role}`).emit(event, data);
};

const emitToAdmin = (event, data) => {
  io.to('admin').emit(event, data);
};

const emitBookingUpdate = (bookingId, customerId, data) => {
  // Emit to customer
  io.to(`customer:${customerId}:bookings`).emit('booking:updated', { bookingId, ...data });
  // Emit to all staff
  io.to('bookings:all').emit('booking:updated', { bookingId, customerId, ...data });
};

const emitPricingUpdate = (data) => {
  io.to('pricing:updates').emit('pricing:updated', data);
};

const emitAnalyticsUpdate = (data) => {
  io.to('analytics:realtime').emit('analytics:updated', data);
};

// Export WebSocket functions for use in routes
app.locals.websocket = {
  emitToUser,
  emitToRole,
  emitToAdmin,
  emitBookingUpdate,
  emitPricingUpdate,
  emitAnalyticsUpdate
};

// Graceful shutdown
process.on('SIGTERM', async () => {
  logger.info('SIGTERM received, shutting down gracefully');
  
  // Close WebSocket servers
  if (analyticsWss) {
    analyticsWss.close();
  }
  
  await pool.end();
  await redisClient.quit();
  
  process.exit(0);
});

process.on('SIGINT', async () => {
  logger.info('SIGINT received, shutting down gracefully');
  
  // Close WebSocket servers
  if (analyticsWss) {
    analyticsWss.close();
  }
  
  await pool.end();
  await redisClient.quit();
  
  process.exit(0);
});

// Start server with Socket.IO and Analytics WebSocket
server.listen(PORT, () => {
  logger.info(`RevivaTech New Platform Backend running on port ${PORT}`);
  logger.info(`WebSocket server enabled with authentication`);
  logger.info(`Analytics WebSocket server enabled on /api/analytics/ws`);
  logger.info(`Environment: ${process.env.NODE_ENV || 'development'}`);
  logger.info(`Features: Real-time analytics, Event tracking, ML scoring`);
});

module.exports = { app, server, io };